# Walico 実装ロジック設計書

## 1. ログイン不要の実装アプローチ

### 1.1 基本的な設計思想

**ログイン不要を実現するための核心設計：**

1. **URL ベースのアクセス制御**

   - 各トランザクションに UUID を発行
   - URL（`/r/[uuid]`）を知っている人だけがアクセス可能
   - これは実質的な「暗黙の認証」として機能

2. **ステートレスな設計**
   - ユーザー情報を一切保持しない
   - トランザクションデータのみを一時的に保存
   - 期限切れデータは自動削除

### 1.2 セキュリティ上の考慮事項

#### [ ] 実装可能な点

1. **トランザクション作成**

   - 誰でも作成可能（問題なし）
   - UUID は十分にランダム（推測不可能）

2. **トランザクション閲覧**

   - URL を知っている人だけが閲覧可能
   - レシート画像も同様に URL ベースでアクセス

3. **支払い完了の更新**
   - URL を知っている人（信頼できる関係者）が更新可能
   - 一度「支払い済み」になったら元に戻せない仕様（誤操作防止）

#### ⚠️ 注意が必要な点

1. **支払い完了の不正更新リスク**

   - 誰でも URL を知っていれば「支払い済み」に変更できてしまう
   - **対策**:
     - URL を LINE で共有するため、基本的に信頼できる関係者のみ
     - 一度「支払い済み」になったら変更不可とする

2. **データの有効期限**
   - 一定期間（7 日など）後に自動削除またはアクセス不可にする
   - Cloudflare R2 の画像も同様にライフサイクルポリシーで削除

## 2. データフロー設計

### 2.1 トランザクション作成フロー

```
1. ユーザーがレシートを撮影/入力
   ↓
2. フロントエンド: データを準備（店名、金額、割り勘比率など）
   ↓
3. API Route: POST /api/transactions
   - UUIDを生成（crypto.randomUUID()）
   - Tursoにデータを保存
   - Cloudflare R2に画像をアップロード（既にアップロード済みの場合、URLを受け取る）
   ↓
4. レスポンス: { id: "uuid", url: "/r/uuid" }
   ↓
5. フロントエンド: LINEアプリを起動（URLスキーム）
   - テキスト: 「[店名]の代金 ¥[請求額] お願い！ レシート詳細: https://walico.app/r/[uuid]」
```

### 2.2 トランザクション閲覧フロー

```
1. ユーザーがURLにアクセス: /r/[id]
   ↓
2. API Route: GET /api/transactions/[id]
   - UUIDでトランザクションを検索
   - 有効期限チェック（expires_at）
   - データを返す
   ↓
3. フロントエンド: データを表示
```

### 2.3 支払い完了フロー

```
1. ユーザーが「支払いを完了する」ボタンをクリック
   ↓
2. API Route: PATCH /api/transactions/[id]/status
   - UUIDでトランザクションを検索
   - status が 'pending' の場合のみ 'paid' に更新
   - 既に 'paid' の場合はエラー（更新不可）
   ↓
3. フロントエンド: 状態を更新し、ボタンを無効化
```

## 3. API 設計

### 3.1 API Routes 構造

```
src/app/api/
  ├── transactions/
  │   ├── route.ts           # POST: トランザクション作成
  │   └── [id]/
  │       ├── route.ts       # GET: トランザクション取得
  │       └── status/
  │           └── route.ts   # PATCH: 支払いステータス更新
  ├── upload/
  │   └── route.ts           # POST: 画像アップロード（Cloudflare R2）
  └── analyze/
      └── route.ts           # POST: AI解析（Gemini）
```

### 3.2 API 仕様

#### POST /api/transactions

**Request Body:**

```typescript
{
  store_name: string | null;
  total_amount: number;
  request_amount: number;
  receipt_image_url: string | null;
  items_json: Array<{ name: string; price: number }> | null;
}
```

**Response:**

```typescript
{
  id: string; // UUID
  url: string; // /r/[id]
}
```

#### GET /api/transactions/[id]

**Response:**

```typescript
{
  id: string;
  store_name: string | null;
  date: string; // ISO 8601形式
  total_amount: number;
  request_amount: number;
  receipt_image_url: string | null;
  items_json: Array<{ name: string; price: number }> | null;
  status: "pending" | "paid";
  created_at: number; // Unix timestamp
  expires_at: number; // Unix timestamp
}
```

#### PATCH /api/transactions/[id]/status

**Request Body:**

```typescript
{
  status: "paid";
}
```

**Response:**

```typescript
{
  id: string;
  status: "paid";
}
```

**エラーケース:**

- 404: トランザクションが見つからない
- 400: 既に支払い済み（status === 'paid'）
- 410: 有効期限切れ（expires_at < 現在時刻）

## 4. データベース設計（Turso/SQLite）

### 4.1 マイグレーション

```sql
CREATE TABLE IF NOT EXISTS transactions (
  id TEXT PRIMARY KEY,
  store_name TEXT,
  total_amount INTEGER NOT NULL,
  request_amount INTEGER NOT NULL,
  receipt_image_url TEXT,
  items_json TEXT,  -- JSON文字列として保存
  status TEXT NOT NULL DEFAULT 'pending' CHECK (status IN ('pending', 'paid')),
  created_at INTEGER NOT NULL,
  expires_at INTEGER NOT NULL
);

-- インデックス（検索速度向上）
CREATE INDEX IF NOT EXISTS idx_transactions_created_at ON transactions(created_at);
CREATE INDEX IF NOT EXISTS idx_transactions_expires_at ON transactions(expires_at);

-- 有効期限切れデータの自動削除用（定期実行が必要）
-- DELETE FROM transactions WHERE expires_at < unixepoch('now');
```

### 4.2 データベース接続（Turso）

**環境変数:**

```env
TURSO_DATABASE_URL=libsql://...
TURSO_AUTH_TOKEN=...
```

**接続例:**

```typescript
import { createClient } from "@libsql/client";

const client = createClient({
  url: process.env.TURSO_DATABASE_URL!,
  authToken: process.env.TURSO_AUTH_TOKEN!,
});
```

## 5. 外部サービス連携

### 5.1 Cloudflare R2（画像アップロード）

**環境変数:**

```env
R2_ACCOUNT_ID=...
R2_ACCESS_KEY_ID=...
R2_SECRET_ACCESS_KEY=...
R2_BUCKET_NAME=...
R2_PUBLIC_URL=...  # パブリックアクセス用のURL
```

**ライフサイクルポリシー:**

- アップロードから 7 日後に自動削除
- または、トランザクションの有効期限と同期

### 5.2 Gemini API（AI 解析）

**環境変数:**

```env
GEMINI_API_KEY=...
```

**解析処理:**

```typescript
// POST /api/analyze
// Request: FormData (image file)
// Response: { store_name, date, items, total_amount }
```

## 6. 実装の優先順位

### Phase 1: コア機能（最小限の動作）

1. [x] Turso 接続設定
2. [x] データベースマイグレーション
3. [x] POST /api/transactions（トランザクション作成）
4. [x] GET /api/transactions/[id]（トランザクション取得）
5. [x] フロントエンド: 入力画面から API 呼び出し
6. [x] フロントエンド: 受信者画面で API からデータ取得

### Phase 2: ステータス管理

1. [x] PATCH /api/transactions/[id]/status（支払い完了）
2. [x] フロントエンド: 支払い完了ボタンの実装

### Phase 3: 画像処理

1. [x] Cloudflare R2 アップロード
2. [x] 画像表示機能

### Phase 4: AI 解析

1. [x] Gemini API 統合
2. [x] レシート解析処理

### Phase 5: 最適化

1. [x] 有効期限切れデータの定期削除（Vercel Cron）
2. [ ] エラーハンドリングの強化
3. [ ] パフォーマンス最適化

## 7. セキュリティ対策のまとめ

### 7.1 URL ベースのアクセス制御で十分な理由

1. **UUID の推測不可能性**

   - crypto.randomUUID()は 128 ビットのランダム値
   - 推測確率は実質的に 0

2. **URL の共有経路**

   - LINE 経由で信頼できる関係者にのみ共有
   - URL を知っている=信頼できる関係者と見なせる

3. **データの一時性**
   - 7 日後には自動削除またはアクセス不可
   - 長期にわたるリスクが低い

### 7.2 追加で検討できる対策（オプション）

1. **レート制限**

   - IP アドレスベースのレート制限
   - 同じ UUID からの過度なリクエストを制限

2. **支払い完了時の確認**

   - 「本当に支払いを完了しましたか？」確認モーダル
   - 誤操作防止

3. **アクセスログ**
   - どの URL にアクセスがあったかログ記録
   - 不正アクセスの検知（ただし、ユーザー情報は保持しない）

## 8. 結論

**ログイン不要の要件は実装可能です。**

理由：

- URL ベースのアクセス制御で十分なセキュリティが確保できる
- トランザクション単位でのデータ管理でユーザー情報が不要
- データの一時性により長期リスクが低い
- 信頼できる関係者間での利用という前提が明確

この設計により、「3 秒で完結」「ログイン不要」というコンセプトを実現できます。
